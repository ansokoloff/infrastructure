# Дипломный проект 

---
ЗАДАЧА

Опишите инфраструктуру будущего проекта в виде кода с инструкциями по развертке, нужен кластер Kubernetes и служебный сервер (будем называть его srv).

Нам нужно три сервера:

два сервера в одном кластере Kubernetes: 1 master и 1 app;
сервер srv для инструментов мониторинга, логгирования и сборок контейнеров.

---

Вся инфраструктура разворачивается с помощью вот этих инструментов:
![](1.jpeg)

Для запуска необходимо откорректировать id проекта в GCP и имя бакета для бэкенда. 

Файл терраформа:
https://github.com/ansokoloff/sprint1/blob/main/main.tf

Команды terraform init, terraform plan, terraform apply -auto-approve.

Дальше все происходит автоматически.

Никаких сенситивных данных нет.

Ключи генерируются во время инициализации окружения и раскладываются в нужные места.

Приватный ключ (для дальнейшего доступа к окружению) копируется на ту машину, откуда был запущен терраформ.

После разворачивания серверов, происходит установка ansible, создание инвентори и конфигурация.
Инвентори создается на данных, полученных из ouptut terraform,
Также копируется плейбук Ansible из репозитория.

Ansible использует роли. Производится доустановка любимого софта, установка докера, установка Jenkins, создание пользователей для Jenkins (потому что srv и kuber используются как ноды для Jenkins), разворачивание кластера k8s.

Плейбук - https://github.com/ansokoloff/sprint1/blob/main/global.yaml

Время полного автоматического разворачивания необходимого окружения - 6 минут 40 секунд.
Репозиторий этого шага со всеми файлами - текущий.

![](1.png)

---
Спринт 2
Клонируем репозиторий, собираем его на сервере srv.
Описываем приложение в Helm-чарт.
Описываем стадию деплоя в Helm.

---

Все эти вещи сделал в рамках одного пайплайна на Jenkins.
Задействованы репозитории:
 - https://github.com/ansokoloff/content.git - исходный код приложения, Jenkinsfile с пайплайном. Вебхуки не настраивал, т.к. приложение у нас статическое и неизменное. Но могу настроить :)
 - https://github.com/ansokoloff/helmchart.git - здесь лежит helm chart
 
 Степы пайплайна:
  1. Клонирование репозитория с кодом.
  2. Сборка докер-имиджа.
  3. Пуш имиджа на hub.docker.com
  4. Клонирование репозитория с helm chart
  5. Добавление версионности в chart
  6. git push
  7. Клонирование этого репозитория в кластере Kubernetes
  8. Деплой приложения.
  
  ![](6.png)
  
  Результат в кластере:
  ![](2.png)
  
  Результат в браузере:
  
  ![](3.png)
  
  Ссылка на страницу - http://34.142.106.107:30003
  Адрес динамический, поэтому может измениться.
  ---
  
  Настройка сборки логов.
  Выбор метрик для мониторинга.
  
  Мы бы хотели знать, когда пользователь не может на него попасть — время отклика, сертификат, статус код и так далее. Выберите метрики и инструмент, с помощью которого будем отслеживать его состояние.
  
  Настройка дашборда.
  
  ---
  
  Для сборки логов использовал Loki + Graphana
  
  ```
  helm repo add grafana https://grafana.github.io/helm-charts
  helm install loki grafana/loki-stack--namespace loki --create-namespace --set grafana.enabled=true
  kubectl port-forward --namespace loki service/loki-grafana 3000:80 --address 0.0.0.0
  
  ```
  Собираю логи пода, и вывожу интересные на дашборд.
  
  ![](5.png)
  
  Для мониторинга приложения использовал связку prometheus, blackbox, nodexporter.
  Использовал классический dockprom (https://github.com/stefanprodan/dockprom.git).
  Т.к. у него нет blackbox, дописал в docker-compose и отредактировал конфиги.
  Репозиторий находится здесь:
  
  https://github.com/ansokoloff/dockprom.git
  
  Дашбоард - здесь:
  
  ![](7.png)
  
  В верхней части - данные с приложения, в нижней - с хостовой машины согласно задания.
  
  ---
  
  А теперь добавим уведомления в наш любимый мессенджер, точнее в ваш любимый мессенджер. Обязательно протестируйте отправку уведомлений. Попробуйте «убить» приложение самостоятельно, и засеките время от инцидента до получения уведомления. Если время адекватное, то можно считать, что вы справились с этим проектом!
  
  ---
  
  Использовал Grafana alerting
  Так как в задании был сделан акцент на метрику свободного места на диске srv, сделал алерт для этой метрики.
  Настроил отправку уведомлений в телеграм-бота.
  Временные рамки отправки уведомлений прикрутил до 10 секунд.
  
  ![](11.png)
  ![](12.png)